package cmd

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"sort"
	"strings"

	"github.com/AlecAivazis/survey/v2"
	"github.com/jenkins-zh/jenkins-cli/app/cmd/common"
	"github.com/jenkins-zh/jenkins-cli/app/i18n"
	"github.com/jenkins-zh/jenkins-cli/client"
	jenkinsFormula "github.com/jenkins-zh/jenkins-formulas/pkg/common"
	cobra_ext "github.com/linuxsuren/cobra-extension"
	"github.com/spf13/cobra"
	"gopkg.in/yaml.v2"
)

//NewPluginOption consists of four options
type NewPluginOption struct {
	Name         string `json:"name"`
	Version      string `json:"gav"`
	Date         string `json:"releaseTimestamp"`
	RequiredCore string `json:"requiredCore"`
}

// PluginFormulaOption option for plugin formula command
type PluginFormulaOption struct {
	cobra_ext.OutputOption

	// OnlyRelease indicated that we only output the release version of plugins
	OnlyRelease bool
	// DockerBuild indicated if build docker image
	DockerBuild  bool
	SortPlugins  bool
	RoundTripper http.RoundTripper
}

var all bool
var pluginFormulaOption PluginFormulaOption

func init() {
	pluginCmd.AddCommand(pluginFormulaCmd)
	flags := pluginFormulaCmd.Flags()
	flags.BoolVarP(&pluginFormulaOption.OnlyRelease, "only-release", "", true,
		`Indicated that we only output the release version of plugins`)
	flags.BoolVarP(&pluginFormulaOption.DockerBuild, "docker-build", "", false,
		`Indicated if build docker image`)
	flags.BoolVarP(&pluginFormulaOption.SortPlugins, "sort-plugins", "", true,
		`Indicated if sort the plugins by name`)
	flags.BoolVarP(&all, "all", "", false, i18n.T("Upgrade jenkins core and all plugins to update"))

	healthCheckRegister.Register(getCmdPath(pluginFormulaCmd), &pluginFormulaOption)
}

// Check do the health check of plugin formula cmd
func (o *PluginFormulaOption) Check() (err error) {
	opt := PluginOptions{
		Option: common.Option{RoundTripper: o.RoundTripper},
	}
	_, err = opt.FindPlugin("pipeline-restful-api")
	return
}

var pluginFormulaCmd = &cobra.Command{
	Use:   "formula",
	Short: i18n.T("Print a formula which contains all plugins come from current Jenkins server"),
	Long: i18n.T(`Print a formula which contains all plugins come from current Jenkins server
Want to know more about what's a Jenkins formula? Please visit https://github.com/jenkins-zh/jenkins-formulas'`),
	Example: `Once you generate the formula file by: jcli plugin formula > test.yaml
than you can package the Jenkins distribution by: jcli cwp --config-path test.yaml`,
	RunE: func(cmd *cobra.Command, _ []string) (err error) {
		jClient := &client.PluginManager{
			JenkinsCore: client.JenkinsCore{
				RoundTripper: pluginFormulaOption.RoundTripper,
			},
		}
		jCoreClient := &client.JenkinsStatusClient{
			JenkinsCore: client.JenkinsCore{
				RoundTripper: pluginFormulaOption.RoundTripper,
			},
		}
		getCurrentJenkinsAndClient(&(jClient.JenkinsCore))
		getCurrentJenkinsAndClient(&(jCoreClient.JenkinsCore))

		var status *client.JenkinsStatus
		if status, err = jCoreClient.Get(); err != nil {
			err = fmt.Errorf("cannot get the version of current Jenkins, error is %v", err)
			return
		}

		//make the formula
		formula := jenkinsFormula.CustomWarPackage{
			Bundle: jenkinsFormula.Bundle{
				GroupId:     "io.github.jenkins-zh",
				ArtifactId:  "jenkins-zh",
				Description: "Jenkins formula generated by jcli",
				Vendor:      "Chinese Jenkins Community",
			},
			BuildSettings: jenkinsFormula.BuildSettings{
				Docker: jenkinsFormula.BuildDockerSetting{
					Build: pluginFormulaOption.DockerBuild,
					Base:  fmt.Sprintf("jenkins/jenkins:%s", status.Version),
					Tag:   "jenkins/jenkins-formula:v0.0.1",
				},
			},
			War: jenkinsFormula.CustomWar{
				GroupId:    "org.jenkins-ci.main",
				ArtifactId: "jenkins-war",
				Source: jenkinsFormula.Source{
					Version: status.Version,
				},
			},
		}
		if all {
			if err = jClient.GetPluginsFormula(&formula.Plugins); err == nil {
				if pluginFormulaOption.OnlyRelease {
					formula.Plugins = removeSnapshotPluginsAndUpgradeOrNot(formula.Plugins, true)
				}
				if pluginFormulaOption.SortPlugins {
					formula.Plugins = SortPlugins(formula.Plugins)
				}
				if items, _, err := GetVersionData(LtsURL); err == nil {
					formula.War.Source.Version = "\"" + items[0].Title[8:] + "\""
				}

				var data []byte
				if data, err = yaml.Marshal(formula); err == nil {
					_, _ = cmd.OutOrStdout().Write(data)
				}
			}
		} else if !all {
			//prompt for core
			var coreTemp bool
			cmd.Println("1  ")
			promptCore := &survey.Confirm{
				Message: fmt.Sprintf("Please indicate whether do you want to upgrade jenkins core or not"),
			}
			cmd.Println("2  ")
			err = survey.AskOne(promptCore, &coreTemp)
			if err != nil {
				return err
			}
			if coreTemp {
				if items, _, err := GetVersionData(LtsURL); err == nil {
					formula.War.Source.Version = "\"" + items[0].Title[8:] + "\""
				}
			}

			if err = jClient.GetPluginsFormula(&formula.Plugins); err == nil {
				if pluginFormulaOption.OnlyRelease {
					formula.Plugins = removeSnapshotPluginsAndUpgradeOrNot(formula.Plugins, false)
				}

				if pluginFormulaOption.SortPlugins {
					formula.Plugins = SortPlugins(formula.Plugins)
				}

				prompt := &survey.MultiSelect{
					Message: fmt.Sprintf("Please select the plugins(%d) which you want to upgrade to the latest: ", len(formula.Plugins)),
					Options: convertFromFormulaToArray(formula.Plugins),
				}
				targetPlugins := make([]string, 0)
				err = survey.AskOne(prompt, &targetPlugins)
				if err != nil {
					return err
				}
				tempMap := make(map[string]bool)
				for _, plugin := range targetPlugins {
					tempMap[plugin] = true
				}
				for index, plugin := range formula.Plugins {
					if _, exist := tempMap[plugin.ArtifactId]; exist {
						formula.Plugins[index].Source.Version, _ = getNewVersionOfPlugin(plugin.ArtifactId)
					}
				}
				var data []byte
				if data, err = yaml.Marshal(formula); err == nil {
					cmd.Println(data)
					_, _ = cmd.OutOrStdout().Write(data)
					// _ = ioutil.WriteFile("test.yaml", data, 0)
				}
			}
		}
		return
	},
	Annotations: map[string]string{
		common.Since: common.VersionSince0031,
	},
}

// SortPlugins sort the plugins by asc
func SortPlugins(plugins []jenkinsFormula.Plugin) []jenkinsFormula.Plugin {
	sort.SliceStable(plugins, func(i, j int) bool {
		if strings.Compare(plugins[j].GroupId, plugins[i].GroupId) > 0 {
			return true
		}
		if strings.Compare(plugins[j].ArtifactId, plugins[i].ArtifactId) > 0 {
			return true
		}
		return false
	})
	return plugins
}

func removeSnapshotPluginsAndUpgradeOrNot(plugins []jenkinsFormula.Plugin, allTmp bool) (result []jenkinsFormula.Plugin) {
	result = make([]jenkinsFormula.Plugin, 0)
	if allTmp {
		for i := range plugins {
			if strings.Contains(plugins[i].Source.Version, "SNAPSHOT") {
				continue
			}
			plugins[i].Source.Version, _ = getNewVersionOfPlugin(plugins[i].ArtifactId)
			result = append(result, plugins[i])
		}
	} else if !allTmp {
		for i := range plugins {
			if strings.Contains(plugins[i].Source.Version, "SNAPSHOT") {
				continue
			}
			result = append(result, plugins[i])
		}
	}
	return result
}

func getNewVersionOfPlugin(shortName string) (version string, err error) {
	api := "https://plugins.jenkins.io/api/plugin/" + shortName
	resp, err := http.Get(api)
	if err != nil {
		return "", err
	}
	bytes, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return "", err
	}
	var newPluginOption NewPluginOption
	err = json.Unmarshal(bytes, &newPluginOption)
	if err != nil {
		return "", err
	}
	content := newPluginOption.Version
	startOfVersionNumber := strings.LastIndex(content, ":")
	version = content[startOfVersionNumber+1:]
	return version, nil
}

func convertFromFormulaToArray(plugins []jenkinsFormula.Plugin) (pluginArray []string) {
	for i, plugin := range plugins {
		pluginArray[i] = plugin.ArtifactId
	}
	return pluginArray
}
